/**************************************************************************//**
 * @file     Smpl_TVP5150.c
 * @brief    Initialize TVP5150 sample code
 *
 * SPDX-License-Identifier: Apache-2.0
 * @copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
*****************************************************************************/

#include "wblib.h"
#include "wbtypes.h"
#include "W55FA92_VideoIn.h"
#include "W55FA92_GPIO.h"
#include "demo.h"
#include "DrvI2C.h"

#ifdef __GNUC__
#include "TVP5150/sensor_tvp5150_reg.h"
#else
#include "TVP5150\sensor_tvp5150_reg.h"
#endif

typedef struct
{
    UINT32 u32Width;
    UINT32 u32Height;
    char* pszFileName;
} S_VIDEOIN_REAL;
typedef struct
{
    UINT32 u32Width;
    UINT32 u32Height;
    E_VIDEOIN_OUT_FORMAT eFormat;
    char* pszFileName;
} S_VIDEOIN_PACKET_FMT;
struct OV_RegValue
{
    UINT8   u8RegAddr;      //Register Address
    UINT8   u8Value;            //Register Data
};

struct OV_RegTable
{
    struct OV_RegValue *sRegTable;
    UINT32 u32TableSize;
};

#define REG_VALUE_INIT      0
#define REG_VALUE_NTSC  1
#define REG_VALUE_PAL       2


#define _REG_TABLE_SIZE(nTableName) (sizeof(nTableName)/sizeof(struct OV_RegValue))
static struct OV_RegValue g_sTVP5150_Init[]=
{
    //8 bit slave address, 8 bit data.
    { /* 0x00 */
        TVP5150_VD_IN_SRC_SEL_1,0x00
    },
    { /* 0x01 */
        TVP5150_ANAL_CHL_CTL,0x15
    },
    { /* 0x02 */
        TVP5150_OP_MODE_CTL,0x00
    },
    { /* 0x03 */
        TVP5150_MISC_CTL,0x09
    },
    { /* 0x06 */
        TVP5150_COLOR_KIL_THSH_CTL,0x10
    },
    { /* 0x07 */
        TVP5150_LUMA_PROC_CTL_1,0x20    // Luma signal delay ::  0 pixel clocks delay 0x20, 0x23, 0x28
    },
    { /* 0x08 */
        TVP5150_LUMA_PROC_CTL_2,0x4C    //Luminance filter select: 0x48 comb filter disabled, chroma trap filter enable !!!!!
    },
    { /* 0x09 */
        TVP5150_BRIGHT_CTL,0x80
    },
    { /* 0x0a */
        TVP5150_SATURATION_CTL,0xA0
    },
    { /* 0x0b */
        TVP5150_HUE_CTL,0x00
    },
    { /* 0x0c */
        TVP5150_CONTRAST_CTL,0x84
    },
    { /* 0x0d */
        TVP5150_DATA_RATE_SEL,0x47
    },
    { /* 0x0e */
        TVP5150_LUMA_PROC_CTL_3,0x00    //Luminance filter stop band bandwidth:: No notch
    },
    { /* 0x0f */
        TVP5150_CONF_SHARED_PIN,0x08
    },
    { /* 0x11 */
        TVP5150_ACT_VD_CROP_ST_MSB,0x00
    },
    { /* 0x12 */
        TVP5150_ACT_VD_CROP_ST_LSB,0x00
    },
    { /* 0x13 */
        TVP5150_ACT_VD_CROP_STP_MSB,0x00
    },
    { /* 0x14 */
        TVP5150_ACT_VD_CROP_STP_LSB,0x00
    },
    { /* 0x15 */
        TVP5150_GENLOCK,0x01
    },
    { /* 0x16 */
        TVP5150_HORIZ_SYNC_START,0x80
    },
    { /* 0x18 */
        TVP5150_VERT_BLANKING_START,0x00
    },
    { /* 0x19 */
        TVP5150_VERT_BLANKING_STOP,0x00
    },
    { /* 0x1a */
        TVP5150_CHROMA_PROC_CTL_1,0x0c
    },
    { /* 0x1b */
        TVP5150_CHROMA_PROC_CTL_2,0x15  //Chrominance filter select: No notch = 0x10
    },
    { /* 0x1c */
        TVP5150_INT_RESET_REG_B,0x00
    },
    { /* 0x1d */
        TVP5150_INT_ENABLE_REG_B,0x00
    },
    { /* 0x1e */
        TVP5150_INTT_CONFIG_REG_B,0x00
    },
    { /* 0x2e */
        TVP5150_MACROVISION_ON_CTR,0x0f
    },
    { /* 0x2f */
        TVP5150_MACROVISION_OFF_CTR,0x01
    },
    { /* 0xbb */
        TVP5150_TELETEXT_FIL_ENA,0x00
    },
    { /* 0xc0 */
        TVP5150_INT_STATUS_REG_A,0x00
    },
    { /* 0xc1 */
        TVP5150_INT_ENABLE_REG_A,0x00
    },
    { /* 0xc2 */
        TVP5150_INT_CONF,0x04
    },
    { /* 0xc8 */
        TVP5150_FIFO_INT_THRESHOLD,0x80
    },
    { /* 0xc9 */
        TVP5150_FIFO_RESET,0x00
    },
    { /* 0xca */
        TVP5150_LINE_NUMBER_INT,0x00
    },
    { /* 0xcb */
        TVP5150_PIX_ALIGN_REG_LOW,0x4e
    },
    { /* 0xcc */
        TVP5150_PIX_ALIGN_REG_HIGH,0x00
    },
    { /* 0xcd */
        TVP5150_FIFO_OUT_CTRL,0x01
    },
    { /* 0xcf */
        TVP5150_FULL_FIELD_ENA,0x00
    },

    { /* 0xd0 */
        TVP5150_LINE_MODE_INI,0x00
    },

    { /* 0xfc */
        TVP5150_FULL_FIELD_MODE_REG, 0x7f
    },

};

static struct OV_RegTable g_OV_InitTable[] =
{
    {g_sTVP5150_Init,_REG_TABLE_SIZE(g_sTVP5150_Init)},
    {0, 0}

};

static UINT8 g_uOvDeviceID[]=
{
    0xBA,           /* If pin SIAD high, 8 bits slave address = 0xBA */
    /* If pin SIAD low, 8 bits slave address = 0xB8 */
};


#ifdef __DEV__
/*
    Sensor power down and reset may default control on sensor daughter board and Reset by RC.
    Sensor alway power on (Keep low)
*/
static void SnrReset(void)
{
    /* GPB04 reset:    H->L->H     */
    //gpio_open(GPIO_PORTB);                    //GPIOB4 as GPIO
    outp32(REG_GPBFUN0, inp32(REG_GPBFUN0) & (~ MF_GPB4));

    gpio_setportval(GPIO_PORTB, 1<<4, 1<<4);    //GPIOB 4 set high default
    gpio_setportpull(GPIO_PORTB, 1<<4, 1<<4);   //GPIOB 4 pull-up
    gpio_setportdir(GPIO_PORTB, 1<<4, 1<<4);    //GPIOB 4 output mode
    sysDelay(3);
    gpio_setportval(GPIO_PORTB, 1<<4, 0<<4);    //GPIOB 4 set low
    sysDelay(3);
    gpio_setportval(GPIO_PORTB, 1<<4, 1<<4);    //GPIOb 4 set high
}

static void SnrPowerDown(BOOL bIsEnable)
{
    /* GPE8 power down, HIGH for power down */
    //gpio_open(GPIO_PORTB);                        //GPIOE as GPIO
    outp32(REG_GPEFUN1, inp32(REG_GPEFUN1) & (~ MF_GPE8));

    gpio_setportval(GPIO_PORTE, 1<<8, 1<<8);        //GPIOE 8 set high default
    gpio_setportpull(GPIO_PORTE, 1<<8, 1<<8);       //GPIOE 8 pull-up
    gpio_setportdir(GPIO_PORTE, 1<<8, 1<<8);        //GPIOE 8 output mode
    if(bIsEnable)
        gpio_setportval(GPIO_PORTE, 1<<8, 1<<8);    //GPIOE 8 set high
    else
        gpio_setportval(GPIO_PORTE, 1<<8, 0);       //GPIOE 8 set low
}
#endif
#ifdef __DEMO__
static void SnrReset(void)
{
    /*  GPE8 reset  */
    //gpio_open(GPIO_PORTB);                        //GPIOE as GPIO
    outp32(REG_GPEFUN1, inp32(REG_GPEFUN1) & (~ MF_GPE8));

    gpio_setportval(GPIO_PORTE, 1<<8, 1<<8);    //GPIOE 8 set high default
    gpio_setportpull(GPIO_PORTE, 1<<8, 1<<8);   //GPIOE 8 pull-up
    gpio_setportdir(GPIO_PORTE, 1<<8, 1<<8);    //GPIOE 8 output mode
    sysDelay(3);
    gpio_setportval(GPIO_PORTE, 1<<8, 0<<8);    //GPIOE 8 set low
    sysDelay(3);
    gpio_setportval(GPIO_PORTE, 1<<8, 1<<8);    //GPIOE 8 set high
}
#endif

void TVP5150SetVideoformat(int std)
{
    UINT8  uDeviceID;
    UINT8  fmt = 0;
    BOOL  ret;

    uDeviceID  = g_uOvDeviceID[REG_VALUE_INIT];

    /* First tests should be against specific std */
    if (std == TVP_STD_ALL)
    {
        fmt=0;  /* Autodetect mode */
    }
    else if (std & TVP_STD_NTSC_443)
    {
        fmt=0xa;
    }
    else if (std & TVP_STD_PAL_M)
    {
        fmt=0x6;
    }
    else if (std & (TVP_STD_PAL_N| TVP_STD_PAL_Nc))
    {
        fmt=0x8;
    }
    else
    {
        /* Then, test against generic ones */
        if (std & TVP_STD_NTSC)
        {
            fmt=0x2;
        }
        else if (std & TVP_STD_PAL)
        {
            fmt=0x4;
        }
    }
    sysprintf("TVP5150 Video format : %02x. \r\n",fmt);
    ret = I2C_Write_8bitSlaveAddr_8bitReg_8bitData(uDeviceID, TVP5150_VIDEO_STD, fmt);
    if(ret==FALSE)
        sysprintf("Programminmg TVP5150 REG 0x%x fail\n", TVP5150_VIDEO_STD);
    else
        sysprintf("Programminmg TVP5150 REG 0x%x successful\n", TVP5150_VIDEO_STD);
}

void TVP5150SetInputSource(int src)
{
    UINT8  uDeviceID;
    UINT8  inputsrc = 0;
    BOOL  ret;

    uDeviceID  = g_uOvDeviceID[REG_VALUE_INIT];

    /* First tests should be against specific std */
    if (src == TVP5150_A1P1A)
    {
        inputsrc=0x00;  /* A1P1A mode */
        sysprintf("TVP5150 Video Input Source : %02x. TVP5150 Channel = A1P1A mode. \r\n",inputsrc);
    }
    else if (src == TVP5150_A1P1B)
    {
        inputsrc=0x02;  /* A1P1B mode */
        sysprintf("TVP5150 Video Input Source : %02x. TVP5150 Channel = A1P1B mode. \r\n",inputsrc);
    }
    else
    {
        inputsrc=0x01;  /* S-Video mode */
        sysprintf("TVP5150 Video Input Source : %02x. TVP5150 Channel = SVIDEO mode. \r\n",inputsrc);
    }

    ret = I2C_Write_8bitSlaveAddr_8bitReg_8bitData(uDeviceID, TVP5150_VD_IN_SRC_SEL_1, inputsrc);
    if(ret==FALSE)
        sysprintf("Programminmg TVP5150 REG 0x%x fail\n", TVP5150_VD_IN_SRC_SEL_1);
    else
        sysprintf("Programminmg TVP5150 REG 0x%x successful\n", TVP5150_VD_IN_SRC_SEL_1);
}
static void TVP_I2c_delay(UINT32 nCount)
{
    volatile UINT32 i;
    for(; nCount!=0; nCount--)
        for(i=0; i<100; i++);
}

#define RETRY   2
static VOID TVP5150_Init(UINT32 nIndex)
{
    UINT32 u32Idx;
    UINT32 u32TableSize;
    UINT8  u8DeviceID;
    UINT8  u8Data;
    BOOL ret;

    struct OV_RegValue *psRegValue;
    DBG_PRINTF("Sensor ID = %d\n", nIndex);
    if ( nIndex >= (sizeof(g_uOvDeviceID)/sizeof(UINT8)) )
        return;

#ifdef __DEV__
    SnrPowerDown(FALSE);
#endif
    SnrReset();

    u32TableSize = g_OV_InitTable[REG_VALUE_INIT].u32TableSize;
    psRegValue = g_OV_InitTable[REG_VALUE_INIT].sRegTable;
    u8DeviceID = g_uOvDeviceID[nIndex];
    DBG_PRINTF("Device Slave Addr = 0x%x\n", u8DeviceID);
    if ( psRegValue == 0 )
        return;

#ifdef __DEV__
#if defined(__1ST_PORT__) || defined(__2ND_PORT__)
    outp32(REG_GPBFUN1, inp32(REG_GPBFUN1) & (~MF_GPB13));
    outp32(REG_GPBFUN1, inp32(REG_GPBFUN1) & (~MF_GPB14));
    DrvI2C_Open(eDRVGPIO_GPIOB,
                eDRVGPIO_PIN13,
                eDRVGPIO_GPIOB,
                eDRVGPIO_PIN14,
                (PFN_DRVI2C_TIMEDELY)TVP_I2c_delay);
#endif
#endif
#ifdef __DEMO__
#if defined(__1ST_PORT__)
    outp32(REG_GPBFUN1, inp32(REG_GPBFUN1) & (~MF_GPB13));
    outp32(REG_GPBFUN1, inp32(REG_GPBFUN1) & (~MF_GPB14));
    DrvI2C_Open(eDRVGPIO_GPIOB,
                eDRVGPIO_PIN13,
                eDRVGPIO_GPIOB,
                eDRVGPIO_PIN14,
                (PFN_DRVI2C_TIMEDELY)TVP_I2c_delay);
#endif
#if defined(__2ND_PORT__)
    outp32(REG_GPBFUN0, inp32(REG_GPBFUN0) & (~MF_GPB4));
    outp32(REG_GPAFUN1, inp32(REG_GPAFUN1) & (~MF_GPA12) | (2<<16));
    DrvI2C_Open(eDRVGPIO_GPIOB,
                eDRVGPIO_PIN4,
                eDRVGPIO_GPIOA,
                eDRVGPIO_PIN12,
                (PFN_DRVI2C_TIMEDELY)TVP_I2c_delay);
    outp32(REG_GPAFUN1, inp32(REG_GPAFUN1) & (~MF_GPA12) | (2<<16));
#endif
#endif

    for(u32Idx=0; u32Idx<u32TableSize; u32Idx++, psRegValue++)
    {
        ret = I2C_Write_8bitSlaveAddr_8bitReg_8bitData(u8DeviceID, (psRegValue->u8RegAddr), (psRegValue->u8Value));
        if(ret==FALSE)
            sysprintf("Programminmg TVP5150 REG 0x%x fail\n", psRegValue->u8RegAddr);
        else
            sysprintf("Programminmg TVP5150 REG 0x%x successful\n", psRegValue->u8RegAddr);
        sysDelay(1);
        u8Data = I2C_Read_8bitSlaveAddr_8bitReg_8bitData(u8DeviceID, (psRegValue->u8RegAddr));
        if(psRegValue->u8RegAddr != 0xC0)
        {
            if(u8Data != (psRegValue->u8Value))
            {
                sysprintf("Programminmg TVP5150 REG 0x%x fail\n", (psRegValue->u8RegAddr));
                u32Idx=u32Idx-1;
                psRegValue = psRegValue-1;
            }
            else
                sysprintf("Programminmg TVP5150 REG 0x%x successful\n", (psRegValue->u8RegAddr));
        }

        //Delay(1000);
    }
#ifdef __NTSC__
    u32TableSize = g_OV_InitTable[REG_VALUE_NTSC].u32TableSize;
    psRegValue = g_OV_InitTable[REG_VALUE_NTSC].sRegTable;
    u8DeviceID = g_uOvDeviceID[nIndex];
    if ( psRegValue == 0 )
        return;
#endif
#ifdef __PAL__
    u32TableSize = g_OV_InitTable[REG_VALUE_PAL].u32TableSize;
    psRegValue = g_OV_InitTable[REG_VALUE_PAL].sRegTable;
    u8DeviceID = g_uOvDeviceID[nIndex];
    if ( psRegValue == 0 )
        return;
#endif

    for(u32Idx=0; u32Idx<u32TableSize; u32Idx++, psRegValue++)
    {
        ret = I2C_Write_8bitSlaveAddr_8bitReg_8bitData(u8DeviceID, (psRegValue->u8RegAddr), (psRegValue->u8Value));
        if(ret==FALSE)
            sysprintf("Programminmg TVP5150 REG 0x%x fail\n", psRegValue->u8RegAddr);
        else
            sysprintf("Programminmg TVP5150 REG 0x%x successful\n", psRegValue->u8RegAddr);

    }


#if defined(CONFIG_PAL_SYSTEM_DEV1)
    TVP5150SetVideoformat(TVP_STD_PAL);
#elif defined(CONFIG_NTSC_SYSTEM_DEV1)
    TVP5150SetVideoformat(TVP_STD_NTSC);
#else       // default PAL
    TVP5150SetVideoformat(TVP_STD_PAL);
#endif
    TVP5150SetInputSource(TVP5150_A1P1A);

    DrvI2C_Close();
}
/*===================================================================
    LCD dimension = (OPT_LCD_WIDTH, OPT_LCD_HEIGHT)
    Packet dimension = (OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT)
    Stride should be LCM resolution  OPT_LCD_WIDTH.
    Packet frame start address = VPOST frame start address + (OPT_LCD_WIDTH-OPT_PREVIEW_WIDTH)/2*2
=====================================================================*/
UINT32 Smpl_TVP5150_OneField(UINT8* pu8FrameBuffer0, UINT8* pu8FrameBuffer1, UINT8* pu8FrameBuffer2)
{
    PFN_VIDEOIN_CALLBACK pfnOldCallback;
    PUINT8 pu8PacketBuf;

    INT32 i32ErrCode;

    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer0 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);
    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer1 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);
    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer2 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);

    InitVPOST(pu8FrameBuffer0);

#ifdef __1ST_PORT__
    i32ErrCode = register_vin_device(1, &Vin);
    if(i32ErrCode<0)
    {
        sysprintf("Register vin 0 device fail\n");
        return (UINT32)-1;
    }
    pVin = &Vin;
    //pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_SNR_CCIR601);
    pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_TVD_CCIR656);
#endif
#ifdef __2ND_PORT__
    i32ErrCode = register_vin_device(2, &Vin);
    if(i32ErrCode<0)
    {
        sysprintf("Register vin 1 device fail\n");
        return (UINT32)-1;
    }
    pVin = &Vin;
    //pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_2ND_SNR_CCIR601);
    pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_2ND_SNR_CCIR601);
#endif
    pVin->Open(48000, 24000);
    TVP5150_Init(0);
    pVin->EnableInt(eVIDEOIN_VINT);

    pVin->InstallCallback(eVIDEOIN_VINT,
                          (PFN_VIDEOIN_CALLBACK)VideoIn_InterruptHandler,
                          &pfnOldCallback );  //Frame End interrupt
    pVin->SetPacketFrameBufferControl(FALSE, FALSE);
    pVin->SetSensorPolarity(FALSE,
                            FALSE,              //Polarity.
                            TRUE);
    pVin->SetDataFormatAndOrder(eVIDEOIN_IN_VYUY, //eVIDEOIN_IN_VYUY,               //Input Order
                                eVIDEOIN_IN_YUV422,         //Intput format
                                eVIDEOIN_OUT_YUV422);           //Output format for packet
    //pVin->SetCropWinStartAddr(0x20,                               //Vertical start position   Y
    //                      0x7A);
#ifdef CONFIG_NTSC_SYSTEM_DEV1
    pVin->SetCropWinStartAddr(0x6,                              //Vertical start position   Y
                              0x6);
#endif
#ifdef CONFIG_PAL_SYSTEM_DEV1
    pVin->SetCropWinStartAddr(0x4,                              //Vertical start position   Y
                              0x3);
#endif


    pVin->SetInputType(1,                   //0: Both fields are disabled. 1: Field 1 enable. 2: Field 2 enable. 3: Both fields are enable
                       eVIDEOIN_TYPE_CCIR656,  //0: CCIR601.   1: CCIR656
                       0);                     //swap?
    pVin->SetStandardCCIR656(FALSE);                        //standard CCIR656 mode


    pVin->SetCropWinSize(OPT_CROP_HEIGHT,                   //UINT16 u16Height,
                         OPT_CROP_WIDTH);                    //UINT16 u16Width;
    pVin->PreviewPipeSize(OPT_PREVIEW_HEIGHT, OPT_PREVIEW_WIDTH);
    pVin->EncodePipeSize(OPT_ENCODE_HEIGHT, OPT_ENCODE_WIDTH);
#ifdef __TV__
    pVin->SetStride(OPT_STRIDE, OPT_ENCODE_WIDTH);
    pVin->SetBaseStartAddress(eVIDEOIN_PACKET, 0, (UINT32)((UINT32)pu8FrameBuffer0) );
#else
    pVin->SetStride(OPT_STRIDE, OPT_ENCODE_WIDTH);
    pVin->SetBaseStartAddress(eVIDEOIN_PACKET, (E_VIDEOIN_BUFFER)0, (UINT32)((UINT32)pu8FrameBuffer0 + (OPT_STRIDE-OPT_PREVIEW_WIDTH)/2*2) );
#endif

    /* Buffer still keep VGA */
    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)0,                            //Planar buffer Y addrress
                              (UINT32)u8PlanarFrameBuffer);

    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)1,                            //Planar buffer U addrress
                              (UINT32)u8PlanarFrameBuffer+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT);

    pVin->SetPlanarFormat(eVIDEOIN_PLANAR_YUV422);              // Planar YUV422/420/macro
    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)2,                            //Planar buffer V addrress
                              (UINT32)u8PlanarFrameBuffer+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT/2);
    pVin->SetPipeEnable(TRUE,                                   // Engine enable?
                        eVIDEOIN_BOTH_PIPE_ENABLE);     // which packet was enabled.

    pVin->SetShadowRegister();
    sysSetLocalInterrupt(ENABLE_IRQ);
    return Successful;
}


UINT32 Smpl_TVP5150_TwoFields(UINT8* pu8FrameBuffer0, UINT8* pu8FrameBuffer1, UINT8* pu8FrameBuffer2)
{
    PFN_VIDEOIN_CALLBACK pfnOldCallback;
    PUINT8 pu8PacketBuf;

    INT32 i32ErrCode;

    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer0 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);
    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer1 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);
    pu8PacketBuf = (PUINT8)((UINT32)pu8FrameBuffer2 | 0x80000000);
    memset(pu8PacketBuf, 0xFF, OPT_PREVIEW_WIDTH*OPT_PREVIEW_HEIGHT*2);

    InitVPOST(pu8FrameBuffer0);

#ifdef __1ST_PORT__
    i32ErrCode = register_vin_device(1, &Vin);
    if(i32ErrCode<0)
    {
        sysprintf("Register vin 0 device fail\n");
        return (UINT32)-1;
    }
    pVin = &Vin;
    pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_SNR_CCIR601);
#endif
#ifdef __2ND_PORT__
    i32ErrCode = register_vin_device(2, &Vin);
    if(i32ErrCode<0)
    {
        sysprintf("Register vin 1 device fail\n");
        return (UINT32)-1;
    }
    pVin = &Vin;
    pVin->Init(TRUE, (E_VIDEOIN_SNR_SRC)eSYS_UPLL, 24000, eVIDEOIN_2ND_SNR_CCIR601);
#endif
    pVin->Open(48000, 24000);
    TVP5150_Init(0);
    pVin->EnableInt(eVIDEOIN_VINT);

    pVin->InstallCallback(eVIDEOIN_VINT,
                          (PFN_VIDEOIN_CALLBACK)VideoIn_InterruptHandler,
                          &pfnOldCallback );  //Frame End interrupt
    pVin->SetPacketFrameBufferControl(FALSE, FALSE);
    pVin->SetSensorPolarity(FALSE,
                            FALSE,              //Polarity.
                            TRUE);
    pVin->SetDataFormatAndOrder(eVIDEOIN_IN_VYUY, //eVIDEOIN_IN_VYUY,               //Input Order
                                eVIDEOIN_IN_YUV422,         //Intput format
                                eVIDEOIN_OUT_YUV422);           //Output format for packet
    //pVin->SetCropWinStartAddr(0x20,                               //Vertical start position   Y
    //                      0x7A);
#ifdef __NTSC__
    pVin->SetCropWinStartAddr(0x6,                              //Vertical start position   Y
                              0x6);
#endif
#ifdef __PAL__
    pVin->SetCropWinStartAddr(0x6,                              //Vertical start position   Y
                              0x6);
#endif


    pVin->SetInputType(3,                   //0: Both fields are disabled. 1: Field 1 enable. 2: Field 2 enable. 3: Both fields are enable
                       eVIDEOIN_TYPE_CCIR656,  //0: CCIR601.   1: CCIR656
                       0);                     //swap?
    pVin->SetStandardCCIR656(FALSE);                //standard CCIR656 mode


    pVin->SetCropWinSize(OPT_CROP_HEIGHT,                   //UINT16 u16Height,
                         OPT_CROP_WIDTH);                    //UINT16 u16Width;
    pVin->PreviewPipeSize(OPT_PREVIEW_HEIGHT, OPT_PREVIEW_WIDTH);
    pVin->EncodePipeSize(OPT_ENCODE_HEIGHT, OPT_ENCODE_WIDTH);
#ifdef __TV__
    pVin->SetStride(OPT_STRIDE, OPT_ENCODE_WIDTH);
    pVin->SetBaseStartAddress(eVIDEOIN_PACKET, 0, (UINT32)((UINT32)pu8FrameBuffer0) );
#else
    pVin->SetStride(OPT_STRIDE, OPT_ENCODE_WIDTH);
    pVin->SetBaseStartAddress(eVIDEOIN_PACKET, (E_VIDEOIN_BUFFER)0, (UINT32)((UINT32)pu8FrameBuffer0 + (OPT_STRIDE-OPT_PREVIEW_WIDTH)/2*2) );
#endif

    /* Buffer still keep VGA */
    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)0,                            //Planar buffer Y addrress
                              (UINT32)u8PlanarFrameBuffer);

    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)1,                            //Planar buffer U addrress
                              (UINT32)u8PlanarFrameBuffer+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT);

    pVin->SetPlanarFormat(eVIDEOIN_PLANAR_YUV422);              // Planar YUV422/420/macro
    pVin->SetBaseStartAddress(eVIDEOIN_PLANAR,
                              (E_VIDEOIN_BUFFER)2,                            //Planar buffer V addrress
                              (UINT32)u8PlanarFrameBuffer+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT+OPT_ENCODE_WIDTH*OPT_ENCODE_HEIGHT/2);
    pVin->SetPipeEnable(TRUE,                                   // Engine enable?
                        eVIDEOIN_BOTH_PIPE_ENABLE);     // which packet was enabled.

    pVin->SetShadowRegister();
    sysSetLocalInterrupt(ENABLE_IRQ);
    return Successful;
}


